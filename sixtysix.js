// Generated by CoffeeScript 1.9.3
(function() {
  'A program to let the user play sixty-six and schnapsen against the computer.\n\nTo do: \n  * Make the computer smarter. ';
  var Card, ComputerAI, Deck, Game, Location, Table, ai, alternateDeals, cardLedWins, cardPath, compareCards, computer, computerCard, computerHaul, computerLead, deck, drawCards, endRound, game, isLegal, isMarriage, lowRank, nextRound, player, playerCard, playerHaul, playerWins, randElement, shuffle, suitNumber, suitString, table, talon, trumpCard, valuePoints, valueRank,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  if (schnapsenMode) {
    lowRank = 'J';
  } else {
    lowRank = '9';
  }

  alternateDeals = 0;

  cardPath = 'images/cards/';

  suitNumber = {
    C: 3,
    D: 0,
    H: 2,
    S: 1
  };

  suitString = {
    C: '&clubs;',
    D: '<span style="color:red">&diams;</span>',
    H: '<span style="color:red">&hearts;</span>',
    S: '&spades;'
  };

  valueRank = {
    9: 9,
    10: 13,
    J: 10,
    Q: 11,
    K: 12,
    A: 14
  };

  valuePoints = {
    9: 0,
    10: 10,
    J: 2,
    Q: 3,
    K: 4,
    A: 11
  };

  randElement = function(array) {
    return array[Math.floor(Math.random() * array.length)];
  };

  ComputerAI = (function() {
    function ComputerAI() {
      this.bestFollow = bind(this.bestFollow, this);
      this.baseCardValues = {
        9: 0,
        10: 10,
        J: 2,
        Q: 3,
        K: 4,
        A: 11
      };
      this.trumpValueBonus = 9;
      this.marriageBonus = 10;
      this.aggressive = false;
    }

    ComputerAI.prototype.cardValue = function(card) {
      var value;
      value = this.baseCardValues[card.value];
      if (card.suit === game.trumpSuit) {
        value += this.trumpValueBonus;
      }
      if (isMarriage(card.id[0], card.id[1], computer) && (!game.deckClosed || schnapsenMode)) {
        value += Math.max(this.marriageBonus - game.round, 0);
      }
      return value;
    };

    ComputerAI.prototype.cardTracker = function(id) {
      var card, ref, ref1, ref2;
      card = deck.find(id);
      if (((ref = card.location) === 'talon' || ref === 'player') && !((ref1 = card.suit, indexOf.call(game.marriages, ref1) >= 0) && ((ref2 = card.value) === 'K' || ref2 === 'Q')) && !talon.isEmpty()) {
        return 'unknown';
      } else {
        return location;
      }
    };

    ComputerAI.prototype.unaccountedCards = function() {
      var card, k, len, ref, results;
      ref = deck.cards;
      results = [];
      for (k = 0, len = ref.length; k < len; k++) {
        card = ref[k];
        if (this.cardTracker(card.id) === 'unknown') {
          results.push(card);
        }
      }
      return results;
    };

    ComputerAI.prototype.beatsAll = function(computerCard, otherCards) {
      var card, wins;
      wins = (function() {
        var k, len, results;
        results = [];
        for (k = 0, len = otherCards.length; k < len; k++) {
          card = otherCards[k];
          results.push(cardLedWins(computerCard, card));
        }
        return results;
      })();
      return wins.reduce(function(x, y) {
        return x && y;
      });
    };

    ComputerAI.prototype.certainWin = function(computerCard) {
      var card, possibleCards, suitMatches;
      possibleCards = this.unaccountedCards().concat(player.getCards());
      if (game.deckClosed) {
        if (player.hasSuit(computerCard.suit)) {
          suitMatches = (function() {
            var k, len, results;
            results = [];
            for (k = 0, len = possibleCards.length; k < len; k++) {
              card = possibleCards[k];
              if (card.suit === computerCard.suit) {
                results.push(card);
              }
            }
            return results;
          })();
          return this.beatsAll(computerCard, suitMatches);
        } else {
          return !player.hasSuit(game.trumpSuit);
        }
      } else {
        return this.beatsAll(computerCard, possibleCards);
      }
    };

    ComputerAI.prototype.topCards = function() {
      var card, hand, other, otherCards;
      otherCards = this.unaccountedCards().concat(player.getCards());
      hand = computer.getCards();
      return (function() {
        var k, len, results;
        results = [];
        for (k = 0, len = hand.length; k < len; k++) {
          card = hand[k];
          if (card.rank > Math.max.apply(Math, ((function() {
            var l, len1, results1;
            results1 = [];
            for (l = 0, len1 = otherCards.length; l < len1; l++) {
              other = otherCards[l];
              if (other.suit === card.suit) {
                results1.push(other.rank);
              }
            }
            return results1;
          })()))) {
            results.push(card);
          }
        }
        return results;
      })();
    };

    ComputerAI.prototype.bestLead = function() {
      var card, certainWinners, likelyPoints, marriageCards, nontrumpOptions, nontrumpWinners, options, topTrumps, toppers, trumpMarriageCards;
      options = computer.getCards();
      nontrumpOptions = (function() {
        var k, len, results;
        results = [];
        for (k = 0, len = options.length; k < len; k++) {
          card = options[k];
          if (!card.isTrump()) {
            results.push(card);
          }
        }
        return results;
      })();
      certainWinners = (function() {
        var k, len, results;
        results = [];
        for (k = 0, len = options.length; k < len; k++) {
          card = options[k];
          if (this.certainWin(card)) {
            results.push(card);
          }
        }
        return results;
      }).call(this);
      nontrumpWinners = (function() {
        var k, len, results;
        results = [];
        for (k = 0, len = certainWinners.length; k < len; k++) {
          card = certainWinners[k];
          if (!card.isTrump()) {
            results.push(card);
          }
        }
        return results;
      })();
      marriageCards = (function() {
        var k, len, results;
        results = [];
        for (k = 0, len = options.length; k < len; k++) {
          card = options[k];
          if (isMarriage(card.value, card.suit, computer)) {
            results.push(card);
          }
        }
        return results;
      })();
      trumpMarriageCards = (function() {
        var k, len, results;
        results = [];
        for (k = 0, len = marriageCards.length; k < len; k++) {
          card = marriageCards[k];
          if (card.suit === game.trumpSuit) {
            results.push(card);
          }
        }
        return results;
      })();
      if (game.playerPoints > 45 || game.computerPoints > 45) {
        this.aggressive = true;
      } else {
        this.aggressive = false;
      }
      toppers = this.topCards();
      if (toppers.length > 0) {
        likelyPoints = ((function() {
          var k, len, results;
          results = [];
          for (k = 0, len = toppers.length; k < len; k++) {
            card = toppers[k];
            results.push(card.points);
          }
          return results;
        })()).reduce(function(a, b) {
          return a + b;
        }) + game.computerPoints;
      } else {
        likelyPoints = 0;
      }
      if (marriageCards.length > 0 && schnapsenMode) {
        likelyPoints += 10;
      }
      if (trumpMarriageCards.length > 0 && schnapsenMode) {
        likelyPoints += 10;
      }
      topTrumps = (function() {
        var k, len, results;
        results = [];
        for (k = 0, len = toppers.length; k < len; k++) {
          card = toppers[k];
          if (card.isTrump()) {
            results.push(card);
          }
        }
        return results;
      })();
      if (((likelyPoints > 55 && topTrumps.length > 1) || (likelyPoints > 65 && topTrumps.length > 0)) && !game.deckClosed) {
        game.computerClose();
      }
      if (nontrumpWinners.length > 0) {
        return randElement(nontrumpWinners).computerPlay();
      } else if (certainWinners.length > 0 && this.aggressive) {
        if (schnapsenMode || (!schnapsenMode && (game.deckClosed || marriageCards.length === 0))) {
          return certainWinners[0].computerPlay();
        } else {
          if (trumpMarriageCards.length > 0) {
            return trumpMarriageCards[0].computerPlay();
          } else {
            return marriageCards[0].computerPlay();
          }
        }
      } else if (marriageCards.length > 0 && (!game.deckClosed || schnapsenMode)) {
        if (trumpMarriageCards.length > 0) {
          return trumpMarriageCards[0].computerPlay();
        } else {
          return marriageCards[0].computerPlay();
        }
      } else {
        return this.worstCard(options).computerPlay();
      }
    };

    ComputerAI.prototype.netValue = function(card, playersCard) {
      if (cardLedWins(playersCard, card)) {
        return -playersCard.points - this.cardValue(card);
      } else {
        return card.points + playersCard.points - this.cardValue(card);
      }
    };

    ComputerAI.prototype.worstCard = function(options) {
      options.sort((function(_this) {
        return function(a, b) {
          return _this.cardValue(a) - _this.cardValue(b);
        };
      })(this));
      return options[0];
    };

    ComputerAI.prototype.bestValue = function(options, playersCard) {
      options.sort((function(_this) {
        return function(a, b) {
          return _this.netValue(b, playersCard) - _this.netValue(a, playersCard);
        };
      })(this));
      return options[0];
    };

    ComputerAI.prototype.bestFollow = function() {
      var card, legalOptions, options, playersCard, winningOptions;
      options = computer.getCards();
      playersCard = playerCard.select();
      if (game.playerPoints > 45 || game.computerPoints > 45) {
        this.aggressive = true;
      } else {
        this.aggressive = false;
      }
      legalOptions = (function() {
        var k, len, results;
        results = [];
        for (k = 0, len = options.length; k < len; k++) {
          card = options[k];
          if (isLegal(playersCard, card, options)) {
            results.push(card);
          }
        }
        return results;
      })();
      winningOptions = (function() {
        var k, len, results;
        results = [];
        for (k = 0, len = legalOptions.length; k < len; k++) {
          card = legalOptions[k];
          if (!cardLedWins(playersCard, card)) {
            results.push(card);
          }
        }
        return results;
      })();
      if (this.aggressive && winningOptions.length > 0) {
        return winningOptions[0].computerPlay();
      } else {
        return this.bestValue(legalOptions, playersCard).computerPlay();
      }
    };

    return ComputerAI;

  })();

  Card = (function() {
    function Card(value, suit) {
      this.swap = bind(this.swap, this);
      this.computerTakes = bind(this.computerTakes, this);
      this.playerTakes = bind(this.playerTakes, this);
      this.computerPlay = bind(this.computerPlay, this);
      this.playCard = bind(this.playCard, this);
      this.cardAction = bind(this.cardAction, this);
      this.suit = suit;
      this.value = value;
      this.rank = valueRank[this.value];
      this.points = valuePoints[this.value];
      this.id = this.value + this.suit;
      this.isTrump = function() {
        return this.suit === game.trumpSuit;
      };
      this.toString = function() {
        return this.value + suitString[this.suit];
      };
      this.front = "<img width = 90px, src='" + cardPath + this.id + ".png'></img>";
      this.back = "<img width = 90px, src='" + cardPath + "back.png'></img>";
      this.turnedUp = false;
      this.html = document.createElement("div");
      this.html.innerHTML = this.back;
      this.html.style.zIndex = 10;
      this.html.style.left = "50px";
      this.html.style.top = "50px";
      this.toNumber = function() {
        return 16 * suitNumber[this.suit] + valueRank[this.value];
      };
      this.location = 'talon';
      this.html.addEventListener("click", this.cardAction);
    }

    Card.prototype.cardAction = function() {
      switch (this.location) {
        case "talon":
          return game.playerClose();
        case "player":
          return this.playCard();
        case "trumpCard":
          return this.swap();
        case "playerHaul":
          return game.showHaul();
        case "computerHaul":
          return game.showComputerHaul();
      }
    };

    Card.prototype.moveTo = function(x, y, z) {
      if (z == null) {
        z = 10;
      }
      this.html.style.left = x + "px";
      this.html.style.top = y + "px";
      return this.html.style.zIndex = z;
    };

    Card.prototype.turnUp = function() {
      this.html.innerHTML = this.front;
      return this.faceUp = true;
    };

    Card.prototype.turnDown = function() {
      this.html.innerHTML = this.back;
      return this.faceUp = false;
    };

    Card.prototype.playCard = function() {
      var gameOver, hand;
      gameOver = false;
      if (playerCard.isEmpty()) {
        hand = player.getCards();
        if (game.playerLeads || isLegal(computerCard.select(), this, hand)) {
          playerCard.placeUp(this);
          if (game.playerLeads) {
            if (isMarriage(this.value, this.suit, player) && (schnapsenMode || !game.deckClosed)) {
              game.marriages += this.suit;
              game.playerMarriages += suitString[this.suit];
              if (this.suit === game.trumpSuit) {
                game.playerPoints += 40;
              } else {
                game.playerPoints += 20;
              }
              game.score();
              gameOver = game.checkWinner();
            }
            if (!gameOver) {
              ai.bestFollow();
            }
          }
          if (!gameOver) {
            return setTimeout(endRound, 1200);
          }
        } else {
          return alert("Now that the stack is closed, you must follow suit! You must also win the trick if you can.");
        }
      }
    };

    Card.prototype.computerPlay = function() {
      var hand;
      hand = computer.getCards();
      computerCard.placeUp(this);
      if (!game.playerLeads) {
        if (isMarriage(this.value, this.suit, computer) && (schnapsenMode || !game.deckClosed)) {
          game.marriages += this.suit;
          game.computerMarriages += suitString[this.suit];
          if (this.suit === game.trumpSuit) {
            game.computerPoints += 40;
            alert('Royal marriage!');
          } else {
            game.computerPoints += 20;
            alert('Marriage!');
          }
          game.score();
          return game.checkWinner();
        }
      }
    };

    Card.prototype.playerTakes = function() {
      playerHaul.stack(this);
      return game.playerPoints += this.points;
    };

    Card.prototype.computerTakes = function() {
      computerHaul.stack(this);
      return game.computerPoints += this.points;
    };

    Card.prototype.swap = function() {
      var newTrump;
      if (player.hasCard(lowRank + game.trumpSuit) && game.playerLeads) {
        player.placeUp(this);
        this.html.style.transform = "rotate(0deg)";
        this.html.style['-webkit-transform'] = "rotate(0deg)";
        newTrump = deck.find(lowRank + game.trumpSuit);
        trumpCard.placeUp(newTrump);
        newTrump.html.style.transform = "rotate(90deg)";
        newTrump.html.style['-webkit-transform'] = "rotate(90deg)";
        return player.display();
      }
    };

    Card.prototype.reset = function() {
      this.turnDown();
      this.location = 'talon';
      this.html.style.transform = 'rotate(0deg)';
      this.html.style['-webkit-transform'] = "rotate(0deg)";
      return this.moveTo(50, 50, 10);
    };

    return Card;

  })();

  Location = (function() {
    function Location(name, x, y, z, visible) {
      this.name = name;
      this.x = x;
      this.y = y;
      this.z = z;
      this.visible = visible;
    }

    Location.prototype.getCards = function() {
      var card, k, len, ref, results;
      ref = deck.cards;
      results = [];
      for (k = 0, len = ref.length; k < len; k++) {
        card = ref[k];
        if (card.location === this.name) {
          results.push(card);
        }
      }
      return results;
    };

    Location.prototype.getSuits = function() {
      var card, k, len, ref, results;
      ref = deck.cards;
      results = [];
      for (k = 0, len = ref.length; k < len; k++) {
        card = ref[k];
        if (card.location === this.name) {
          results.push(card.suit);
        }
      }
      return results;
    };

    Location.prototype.select = function() {
      return this.getCards().pop();
    };

    Location.prototype.hasSuit = function(suit) {
      var card;
      return indexOf.call((function() {
        var k, len, ref, results;
        ref = this.getCards();
        results = [];
        for (k = 0, len = ref.length; k < len; k++) {
          card = ref[k];
          results.push(card.suit);
        }
        return results;
      }).call(this), suit) >= 0;
    };

    Location.prototype.hasCard = function(id) {
      var card;
      return indexOf.call((function() {
        var k, len, ref, results;
        ref = this.getCards();
        results = [];
        for (k = 0, len = ref.length; k < len; k++) {
          card = ref[k];
          results.push(card.id);
        }
        return results;
      }).call(this), id) >= 0;
    };

    Location.prototype.isEmpty = function() {
      return this.getCards().length === 0;
    };

    Location.prototype.stack = function(newCard) {
      var height;
      height = this.getCards().length;
      if (this.visible) {
        newCard.moveTo(this.x + 15 * height, this.y, this.z + height);
        newCard.turnUp();
      } else {
        newCard.moveTo(this.x - 2 * height, this.y, this.z + height);
        newCard.turnDown();
      }
      return newCard.location = this.name;
    };

    Location.prototype.placeUp = function(newCard) {
      newCard.turnUp();
      newCard.location = this.name;
      return newCard.moveTo(this.x, this.y, this.z);
    };

    Location.prototype.placeDown = function(newCard) {
      newCard.turnDown();
      newCard.location = this.name;
      return newCard.moveTo(this.x, this.y, this.z);
    };

    Location.prototype.display = function() {
      var card, hand, i, k, len, results;
      hand = this.getCards();
      hand.sort(compareCards);
      results = [];
      for (i = k = 0, len = hand.length; k < len; i = ++k) {
        card = hand[i];
        results.push(card.moveTo(this.x + 100 * i, this.y, this.z));
      }
      return results;
    };

    return Location;

  })();

  Game = (function() {
    function Game() {
      this.startNext = bind(this.startNext, this);
      this.checkWinner = bind(this.checkWinner, this);
      this.toggleScorebar = bind(this.toggleScorebar, this);
      this.computerClose = bind(this.computerClose, this);
      this.playerClose = bind(this.playerClose, this);
      this.computerPoints = 0;
      this.playerPoints = 0;
      this.computerGamepoints = 0;
      this.playerGamepoints = 0;
      this.marriages = '';
      this.computerMarriages = '';
      this.playerMarriages = '';
      this.trumpSuit = '';
      this.playerLeads = true;
      this.deckClosed = false;
      this.deckCloser = '';
      this.nonCloserPoints = 0;
      this.round = 1;
      this.gameNumber = 1;
      this.carryOverPoints = 0;
      this.showScore = true;
    }

    Game.prototype.initialize = function() {
      var card, i, k, l, len, len1, len2, len3, len4, len5, len6, m, n, o, p, q, ref, ref1, ref2, ref3, ref4, ref5, ref6, special;
      deck.shuffle();
      if (schnapsenMode) {
        ref = deck.cards.slice(15, 20);
        for (k = 0, len = ref.length; k < len; k++) {
          card = ref[k];
          player.placeUp(card);
        }
      } else {
        ref1 = deck.cards.slice(18, 24);
        for (l = 0, len1 = ref1.length; l < len1; l++) {
          card = ref1[l];
          player.placeUp(card);
        }
      }
      player.display();
      if (schnapsenMode) {
        ref2 = deck.cards.slice(10, 15);
        for (m = 0, len2 = ref2.length; m < len2; m++) {
          card = ref2[m];
          computer.placeDown(card);
        }
      } else {
        ref3 = deck.cards.slice(12, 18);
        for (n = 0, len3 = ref3.length; n < len3; n++) {
          card = ref3[n];
          computer.placeDown(card);
        }
      }
      if (schnapsenMode) {
        special = deck.cards[9];
      } else {
        special = deck.cards[11];
      }
      trumpCard.placeUp(special);
      special.html.style.transform = "rotate(90deg)";
      special.html.style['-webkit-transform'] = "rotate(90deg)";
      this.trumpSuit = special.suit;
      if (schnapsenMode) {
        ref4 = deck.cards.slice(0, 9);
        for (o = 0, len4 = ref4.length; o < len4; o++) {
          card = ref4[o];
          card.location = 'talon';
        }
      } else {
        ref5 = deck.cards.slice(0, 11);
        for (p = 0, len5 = ref5.length; p < len5; p++) {
          card = ref5[p];
          card.location = 'talon';
        }
      }
      ref6 = talon.getCards();
      for (i = q = 0, len6 = ref6.length; q < len6; i = ++q) {
        card = ref6[i];
        card.moveTo(talon.x - 2 * i, talon.y, talon.z + i);
      }
      document.getElementById("scorebar").addEventListener("click", game.toggleScorebar);
      return this.score();
    };

    Game.prototype.playerDraw = function(location) {
      var card;
      card = location.select();
      player.placeUp(card);
      return player.display();
    };

    Game.prototype.computerDraw = function(location) {
      var card;
      card = location.select();
      return computer.placeDown(card);
    };

    Game.prototype.playerClose = function() {
      if (this.playerLeads) {
        trumpCard.getCards()[0].turnDown();
        this.deckClosed = true;
        this.deckCloser = 'player';
        return this.nonCloserPoints = Math.max(this.computerPoints * (!computerHaul.isEmpty()), !computerHaul.isEmpty());
      }
    };

    Game.prototype.computerClose = function() {
      alert("I'm closing the stack.");
      trumpCard.getCards()[0].turnDown();
      this.deckClosed = true;
      this.deckCloser = 'computer';
      return this.nonCloserPoints = Math.max(this.playerPoints * (!playerHaul.isEmpty()), !playerHaul.isEmpty());
    };

    Game.prototype.score = function() {
      var computerProvisional, playerProvisional;
      if (playerHaul.isEmpty()) {
        playerProvisional = 0;
      } else {
        playerProvisional = this.playerPoints;
      }
      if (computerHaul.isEmpty()) {
        computerProvisional = 0;
      } else {
        computerProvisional = this.computerPoints;
      }
      if (this.showScore) {
        return document.getElementById("scorebar").innerHTML = "<p>You: " + playerProvisional + " points. " + this.playerMarriages + " &nbsp;  &nbsp; &nbsp; &nbsp; &nbsp; Trump: <span style='font-size:24px;'>" + suitString[this.trumpSuit] + "</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Computer: " + computerProvisional + " points. " + this.computerMarriages;
      } else {
        return document.getElementById("scorebar").innerHTML = "<p>Score bar hidden. Click again to show scores.<span style='font-size:24px;'> &nbsp; </span>";
      }
    };

    Game.prototype.toggleScorebar = function() {
      if (this.showScore) {
        this.showScore = false;
        return this.score();
      } else {
        this.showScore = true;
        return this.score();
      }
    };

    Game.prototype.checkWinner = function(lastTrickWinner) {
      var gameOver;
      if (lastTrickWinner == null) {
        lastTrickWinner = 'none';
      }
      gameOver = false;
      this.score();
      if (this.deckCloser.length > 0) {
        if (this.playerPoints > 65 || this.computerPoints > 65) {
          gameOver = true;
          if (this.playerPoints > 65) {
            if (this.deckCloser === 'player') {
              this.playerLeads = false;
              if (!schnapsenMode) {
                this.nonCloserPoints = Math.max(this.computerPoints * (!computerHaul.isEmpty()), !computerHaul.isEmpty());
              }
              if (this.nonCloserPoints === 0) {
                this.announceWinner('player', 3);
              }
              if (this.nonCloserPoints > 0 && this.nonCloserPoints < 33) {
                this.announceWinner('player', 2);
              }
              if (this.nonCloserPoints >= 33) {
                this.announceWinner('player', 1);
              }
            } else {
              this.playerLeads = false;
              if (this.nonCloserPoints > 0) {
                this.announceWinner('player', 2, 'Unsuccessful close. ');
              } else {
                this.announceWinner('player', 3, 'Unsuccessful close. ');
              }
            }
          } else {
            if (this.deckCloser === 'computer') {
              this.playerLeads = true;
              if (!schnapsenMode) {
                this.nonCloserPoints = Math.max(this.playerPoints * (!playerHaul.isEmpty()), !playerHaul.isEmpty());
              }
              if (this.nonCloserPoints === 0) {
                this.announceWinner('computer', 3);
              }
              if (this.nonCloserPoints > 0 && this.nonCloserPoints < 33) {
                this.announceWinner('computer', 2);
              }
              if (this.nonCloserPoints >= 33) {
                this.announceWinner('computer', 1);
              }
            } else {
              this.playerLeads = true;
              if (this.nonCloserPoints > 0) {
                this.announceWinner('computer', 2, 'Unsuccessful close. ');
              } else {
                this.announceWinner('computer', 3, 'Unsuccessful close. ');
              }
            }
          }
          this.nextGame();
        } else {
          if (player.getCards().length === 0) {
            gameOver = true;
            if (this.deckCloser === 'player') {
              this.playerLeads = true;
              if (this.nonCloserPoints > 0) {
                this.announceWinner('computer', 2, 'Unsuccessful close. ');
              } else {
                this.announceWinner('computer', 3, 'Unsuccessful close. ');
              }
            } else {
              this.playerLeads = false;
              if (this.nonCloserPoints > 0) {
                this.announceWinner('player', 2, 'Unsuccessful close. ');
              } else {
                this.announceWinner('player', 3, 'Unsuccessful close. ');
              }
            }
            this.nextGame();
          }
        }
      } else {
        if (this.playerPoints > 65 || this.computerPoints > 65) {
          gameOver = true;
          if (this.playerPoints > 65 || lastTrickWinner === 'player') {
            this.playerLeads = false;
            if (computerHaul.isEmpty()) {
              this.announceWinner('player', 3);
            } else {
              if (this.computerPoints < 33) {
                this.announceWinner('player', 2);
              } else {
                this.announceWinner('player', 1);
              }
            }
          } else {
            this.playerLeads = true;
            if (playerHaul.isEmpty()) {
              this.announceWinner('computer', 3);
            } else {
              if (this.playerPoints < 33) {
                this.announceWinner('computer', 2);
              } else {
                this.announceWinner('computer', 1);
              }
            }
          }
          this.nextGame();
        } else {
          if (player.isEmpty() && this.playerPoints === 65 && this.computerPoints === 65) {
            gameOver = true;
            if (schnapsenMode) {
              this.announceWinner(lastTrickWinner, 1);
            } else {
              this.announceWinner('tie', 0);
            }
            this.nextGame();
          }
        }
      }
      return gameOver;
    };

    Game.prototype.announceWinner = function(winner, points, preamble) {
      var rest, subject, text, winnings;
      if (preamble == null) {
        preamble = '';
      }
      if (winner === 'tie') {
        this.carryOverPoints += 1;
        text = "It's a tie! The winner of the next round will get 1 extra game point.\n \n";
        rest = "So far the score is: \n \n Computer: " + this.computerGamepoints + " \n Player: " + this.playerGamepoints + " \n \n Would you like to keep playing? \n \n";
        alert(text + rest);
      } else {
        points += this.carryOverPoints;
        this.carryOverPoints = 0;
        if (winner === 'player') {
          this.playerGamepoints += points;
        } else {
          this.computerGamepoints += points;
        }
        subject = {
          'player': "You win " + this.playerPoints + " to " + this.computerPoints + " ",
          'computer': "The computer wins " + this.computerPoints + " to " + this.playerPoints + " "
        };
        if (points > 1) {
          winnings = "(" + points + " game points). \n \n";
        } else {
          winnings = "(" + points + " game point). \n \n";
        }
        rest = "So far the score is \n \n Computer: " + this.computerGamepoints + " \n Player: " + this.playerGamepoints + " \n \n Would you like to keep playing? \n \n";
        alert(preamble + subject[winner] + winnings + rest);
      }
    };

    Game.prototype.nextGame = function() {
      var card, k, len, ref;
      ref = deck.cards;
      for (k = 0, len = ref.length; k < len; k++) {
        card = ref[k];
        card.reset();
      }
      this.round = 1;
      this.gameNumber += 1;
      this.computerPoints = 0;
      this.playerPoints = 0;
      this.marriages = '';
      this.computerMarriages = '';
      this.playerMarriages = '';
      this.trumpSuit = '';
      this.deckClosed = false;
      this.deckCloser = '';
      this.nonCloserPoints = 0;
      return setTimeout(this.startNext, 1000);
    };

    Game.prototype.startNext = function() {
      this.initialize();
      if (schnapsenMode || alternateDeals) {
        this.playerLeads = this.gameNumber % 2 === 1;
      }
      if (this.playerLeads === false) {
        return setTimeout(computerLead, 1000);
      }
    };

    Game.prototype.showHaul = function() {
      var card, k, l, len, len1, len2, len3, m, n, ref, ref1, ref2, ref3, results, results1;
      if (playerHaul.visible) {
        ref = playerHaul.getCards();
        for (k = 0, len = ref.length; k < len; k++) {
          card = ref[k];
          card.turnDown();
        }
        playerHaul.visible = false;
        ref1 = playerHaul.getCards();
        results = [];
        for (l = 0, len1 = ref1.length; l < len1; l++) {
          card = ref1[l];
          results.push(card.moveTo(playerHaul.x - 2 * (card.html.style.zIndex - playerHaul.z), playerHaul.y, card.html.style.zIndex));
        }
        return results;
      } else {
        ref2 = playerHaul.getCards();
        for (m = 0, len2 = ref2.length; m < len2; m++) {
          card = ref2[m];
          card.turnUp();
        }
        playerHaul.visible = true;
        ref3 = playerHaul.getCards();
        results1 = [];
        for (n = 0, len3 = ref3.length; n < len3; n++) {
          card = ref3[n];
          results1.push(card.moveTo(playerHaul.x + 15 * (card.html.style.zIndex - playerHaul.z), playerHaul.y, card.html.style.zIndex));
        }
        return results1;
      }
    };

    Game.prototype.showComputerHaul = function() {
      var card, k, l, len, len1, len2, len3, m, n, ref, ref1, ref2, ref3, results, results1;
      if (computerHaul.visible) {
        ref = computerHaul.getCards();
        for (k = 0, len = ref.length; k < len; k++) {
          card = ref[k];
          card.turnDown();
        }
        computerHaul.visible = false;
        ref1 = computerHaul.getCards();
        results = [];
        for (l = 0, len1 = ref1.length; l < len1; l++) {
          card = ref1[l];
          results.push(card.moveTo(computerHaul.x - 2 * (card.html.style.zIndex - computerHaul.z), computerHaul.y, card.html.style.zIndex));
        }
        return results;
      } else {
        ref2 = computerHaul.getCards();
        for (m = 0, len2 = ref2.length; m < len2; m++) {
          card = ref2[m];
          card.turnUp();
        }
        computerHaul.visible = true;
        ref3 = computerHaul.getCards();
        results1 = [];
        for (n = 0, len3 = ref3.length; n < len3; n++) {
          card = ref3[n];
          results1.push(card.moveTo(computerHaul.x + 15 * (card.html.style.zIndex - computerHaul.z), computerHaul.y, card.html.style.zIndex));
        }
        return results1;
      }
    };

    return Game;

  })();

  Deck = (function() {
    function Deck() {
      var cards, k, l, len, len1, num, suit, suits, values;
      suits = ['C', 'D', 'H', 'S'];
      if (schnapsenMode) {
        values = ['10', 'J', 'Q', 'K', 'A'];
      } else {
        values = ['9', '10', 'J', 'Q', 'K', 'A'];
      }
      cards = [];
      for (k = 0, len = suits.length; k < len; k++) {
        suit = suits[k];
        for (l = 0, len1 = values.length; l < len1; l++) {
          num = values[l];
          cards.push(new Card(num, suit));
        }
      }
      this.cards = cards;
    }

    Deck.prototype.find = function(id) {
      var card;
      return ((function() {
        var k, len, ref, results;
        ref = deck.cards;
        results = [];
        for (k = 0, len = ref.length; k < len; k++) {
          card = ref[k];
          if (card.id === id) {
            results.push(card);
          }
        }
        return results;
      })())[0];
    };

    Deck.prototype.shuffle = function() {
      return shuffle(this.cards);
    };

    return Deck;

  })();

  Table = (function() {
    function Table() {
      var card, k, len, ref;
      this.html = document.getElementById('table');
      ref = deck.cards;
      for (k = 0, len = ref.length; k < len; k++) {
        card = ref[k];
        this.html.appendChild(card.html);
      }
    }

    return Table;

  })();

  isLegal = function(cardLed, card2, hand2) {
    var card, suitFollowers, suitWinners, trumpCards;
    suitFollowers = (function() {
      var k, len, results;
      results = [];
      for (k = 0, len = hand2.length; k < len; k++) {
        card = hand2[k];
        if (card.suit === cardLed.suit) {
          results.push(card);
        }
      }
      return results;
    })();
    suitWinners = (function() {
      var k, len, results;
      results = [];
      for (k = 0, len = suitFollowers.length; k < len; k++) {
        card = suitFollowers[k];
        if (card.rank > cardLed.rank) {
          results.push(card);
        }
      }
      return results;
    })();
    trumpCards = (function() {
      var k, len, results;
      results = [];
      for (k = 0, len = hand2.length; k < len; k++) {
        card = hand2[k];
        if (card.isTrump()) {
          results.push(card);
        }
      }
      return results;
    })();
    if (!game.deckClosed) {
      return true;
    } else if (suitFollowers.length > 0) {
      if (suitWinners.length > 0) {
        return card2.suit === cardLed.suit && card2.rank > cardLed.rank;
      } else {
        return card2.suit === cardLed.suit;
      }
    } else if (trumpCards.length > 0) {
      return card2.isTrump();
    } else {
      return true;
    }
  };

  computerLead = function() {
    var newTrump, oldTrump;
    if (!game.deckClosed && computer.hasCard(lowRank + game.trumpSuit)) {
      alert("I'm swapping the trump card.");
      oldTrump = trumpCard.select();
      newTrump = deck.find(lowRank + game.trumpSuit);
      oldTrump.html.style.transform = "rotate(0deg)";
      oldTrump.html.style['-webkit-transform'] = "rotate(0deg)";
      newTrump.html.style.transform = "rotate(90deg)";
      newTrump.html.style['-webkit-transform'] = "rotate(90deg)";
      computer.placeDown(oldTrump);
      trumpCard.placeUp(newTrump);
    }
    return ai.bestLead();
  };

  isMarriage = (function(_this) {
    return function(value, suit, handLocation) {
      var partner;
      partner = {
        'K': 'Q',
        'Q': 'K'
      };
      return (value === 'K' || value === 'Q') && handLocation.hasCard(partner[value] + suit);
    };
  })(this);

  endRound = function() {
    var lastTrickWinner;
    if (playerWins()) {
      playerCard.select().playerTakes();
      computerCard.select().playerTakes();
      game.playerLeads = true;
      lastTrickWinner = 'player';
    } else {
      playerCard.select().computerTakes();
      computerCard.select().computerTakes();
      game.playerLeads = false;
      lastTrickWinner = 'computer';
    }
    if (player.isEmpty() && talon.isEmpty()) {
      if (game.playerLeads) {
        game.playerPoints += 10;
      } else {
        game.computerPoints += 10;
      }
      game.score();
    }
    if (!game.checkWinner(lastTrickWinner)) {
      return nextRound();
    }
  };

  nextRound = function() {
    if (!game.deckClosed && game.round > 0) {
      drawCards();
    }
    player.display();
    if (!game.playerLeads) {
      setTimeout(computerLead, 1000);
    }
    return game.round += 1;
  };

  drawCards = function() {
    var special;
    if (talon.getCards().length === 1) {
      special = trumpCard.select();
      special.html.style.transform = "rotate(0deg)";
      special.html.style['-webkit-transform'] = "rotate(0deg)";
      if (game.playerLeads) {
        game.playerDraw(talon);
        computer.placeDown(special);
      } else {
        computer.placeDown(talon.select());
        game.playerDraw(trumpCard);
      }
      return game.deckClosed = true;
    } else {
      game.playerDraw(talon);
      return game.computerDraw(talon);
    }
  };


  /*
  Randomize array element order in-place
  using Fisher-Yates shuffle algorithm.
   */

  shuffle = function(array) {
    var i, j, temp;
    i = array.length - 1;
    while (i > 0) {
      j = Math.floor(Math.random() * (i + 1));
      temp = array[i];
      array[i] = array[j];
      array[j] = temp;
      i--;
    }
    return array;
  };

  cardLedWins = function(cardLed, card2) {
    if (card2.suit === game.trumpSuit) {
      return cardLed.suit === game.trumpSuit && cardLed.rank > card2.rank;
    } else {
      return cardLed.rank > card2.rank || cardLed.suit !== card2.suit;
    }
  };

  compareCards = function(card1, card2) {
    return card2.toNumber() - card1.toNumber();
  };

  playerWins = function() {
    var card1, card2, leaderLoses;
    if (game.playerLeads) {
      card1 = playerCard.select();
      card2 = computerCard.select();
    } else {
      card1 = computerCard.select();
      card2 = playerCard.select();
    }
    leaderLoses = ((card1.suit === card2.suit) && (valueRank[card1.value] < valueRank[card2.value])) || (card1.suit !== game.trumpSuit && card2.suit === game.trumpSuit);
    return leaderLoses !== game.playerLeads;
  };

  game = new Game();

  deck = new Deck();

  table = new Table();

  ai = new ComputerAI();

  talon = new Location('talon', 50, 50, 10, false);

  player = new Location('player', 50, 200, 50, true);

  computer = new Location('computer', 200, -300, 50, false);

  playerCard = new Location('playerCard', 450, 50, 10, true);

  computerCard = new Location('computerCard', 350, 50, 10, true);

  if (schnapsenMode) {
    playerHaul = new Location('playerHaul', 650, 200, 10, false);
    computerHaul = new Location('computerHaul', 650, 50, 10, false);
  } else {
    playerHaul = new Location('playerHaul', 750, 200, 10, false);
    computerHaul = new Location('computerHaul', 750, 50, 10, false);
  }

  trumpCard = new Location('trumpCard', 100, 50, 5, true);

  window.onload = function() {
    return game.initialize();
  };

}).call(this);
